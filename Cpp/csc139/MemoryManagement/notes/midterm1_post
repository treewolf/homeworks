A1.	spinlocks; running or waiting; avoid context switching and never preempted
	mutex;	waiting; doesn't waste cpu cycle

B1.	c; protecting a cirtical section with semephore ensures mutual exclusion because when in the CS, any process that tries to
	access the CS that is protected by the same semaphore is placed in the waiting state. the process can lose cpu.

B2.	d; if only 1/4 of the code is parallelizable, the maximum speedup factor that can be achieved on a quad-core system under ideal conditions is 16/13.

B3.	f; for concurrency and parallelization. pareallelism requires multipe cpus while concurrency may be achieved on a single CPU;
	and with concurrency, only one process may be running at a given point in time while with parelleism multple processes may be running sumultaneously.

B4.	a; about shared memory and message passing, shared memory is not slower than message passing on all multiprocessor systems;
	shared memory is faster than message passing o all single processor systems;
	In shared memory, kenrel intervention is needed only to setup the shared memory block;
	In message passing, every send/recieve goes throught he kernel.

B5.	b; I/O request will cause OS to put a process in the waiting state.

B6.	b; For RPC, the user program does not communicate directly with the matchmaker without kernel intervention.

producer-consumer
wait(mutex)
SetProdItemCnt(GetProdItemCount()-1)
post(mutex)

dining-philospher - STUDY
every phil picks up one chiopstick and waits for the other.
each function is a critical section and the monitor prevents deadlocks.
a problem for a phil that starts eating if not hungry, is that it may keep resource forever and never return to system,
and is a waste of resources.
